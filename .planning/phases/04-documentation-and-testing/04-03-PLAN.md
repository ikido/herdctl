---
phase: 04-documentation-and-testing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/runner/runtime/__tests__/factory.test.ts
  - packages/core/src/runner/runtime/__tests__/cli-output-parser.test.ts
  - packages/core/src/runner/runtime/__tests__/cli-session-path.test.ts
  - packages/core/src/runner/runtime/__tests__/docker-config.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests exist for RuntimeFactory selection logic"
    - "Unit tests verify CLI output parsing transforms JSONL to SDK messages"
    - "Unit tests validate Docker config resolution with defaults"
    - "All unit tests pass with pnpm test"
  artifacts:
    - path: "packages/core/src/runner/runtime/__tests__/factory.test.ts"
      provides: "RuntimeFactory unit tests"
      min_lines: 80
    - path: "packages/core/src/runner/runtime/__tests__/cli-output-parser.test.ts"
      provides: "CLI output parser unit tests"
      min_lines: 100
    - path: "packages/core/src/runner/runtime/__tests__/docker-config.test.ts"
      provides: "Docker config unit tests"
      min_lines: 100
  key_links:
    - from: "packages/core/src/runner/runtime/__tests__/factory.test.ts"
      to: "packages/core/src/runner/runtime/factory.ts"
      via: "imports RuntimeFactory"
      pattern: "import.*RuntimeFactory.*from"
    - from: "packages/core/src/runner/runtime/__tests__/docker-config.test.ts"
      to: "packages/core/src/runner/runtime/docker-config.ts"
      via: "imports resolveDockerConfig"
      pattern: "import.*resolveDockerConfig.*from"
---

<objective>
Create unit tests for runtime implementations and configuration

Purpose: Achieve 85% unit test coverage for runtime factory, CLI parsing, and Docker configuration
Output: Test files for factory.ts, cli-output-parser.ts, cli-session-path.ts, and docker-config.ts
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-documentation-and-testing/04-CONTEXT.md

# Source files to test
@packages/core/src/runner/runtime/factory.ts
@packages/core/src/runner/runtime/cli-output-parser.ts
@packages/core/src/runner/runtime/cli-session-path.ts
@packages/core/src/runner/runtime/docker-config.ts

# Test patterns reference
@packages/core/src/runner/__tests__/job-executor.test.ts
@packages/core/src/config/__tests__/schema.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RuntimeFactory Unit Tests</name>
  <files>packages/core/src/runner/runtime/__tests__/factory.test.ts</files>
  <action>
Create unit tests for RuntimeFactory at `packages/core/src/runner/runtime/__tests__/factory.test.ts`.

Follow existing test patterns using Vitest (describe/it/expect/vi).

Test cases to implement:

1. **Runtime type selection**:
   - Default to SDK runtime when `runtime` not specified
   - Create SDK runtime when `runtime: "sdk"`
   - Create CLI runtime when `runtime: "cli"`
   - Throw error for unknown runtime type

2. **Docker wrapping**:
   - Return base runtime when `docker.enabled` is false/undefined
   - Wrap with ContainerRunner when `docker.enabled` is true
   - Pass stateDir to ContainerRunner
   - Use default stateDir when not provided

3. **Combined scenarios**:
   - SDK + Docker: SDK wrapped with ContainerRunner
   - CLI + Docker: CLI wrapped with ContainerRunner

Test structure:
```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { RuntimeFactory } from "../factory.js";
import type { ResolvedAgent } from "../../../config/index.js";

// Helper to create test agent
function createTestAgent(overrides: Partial<ResolvedAgent> = {}): ResolvedAgent {
  return {
    name: "test-agent",
    configPath: "/path/to/agent.yaml",
    ...overrides,
  };
}

describe("RuntimeFactory", () => {
  describe("runtime type selection", () => {
    it("defaults to SDK runtime when runtime not specified", () => {
      const agent = createTestAgent();
      const runtime = RuntimeFactory.create(agent);
      // Verify it's SDKRuntime (check constructor name or instanceof)
      expect(runtime.constructor.name).toBe("SDKRuntime");
    });

    it("creates SDK runtime for runtime: sdk", () => { ... });
    it("creates CLI runtime for runtime: cli", () => { ... });
    it("throws for unknown runtime type", () => { ... });
  });

  describe("Docker wrapping", () => {
    it("returns base runtime when docker not enabled", () => { ... });
    it("wraps with ContainerRunner when docker.enabled is true", () => { ... });
    it("passes stateDir to ContainerRunner", () => { ... });
    it("uses default stateDir when not provided", () => { ... });
  });

  describe("combined scenarios", () => {
    it("wraps SDK with Docker", () => { ... });
    it("wraps CLI with Docker", () => { ... });
  });
});
```

Important: For Docker wrapping tests, check the runtime chain by verifying the outer runtime is ContainerRunner. You may need to check constructor.name or use type guards.
  </action>
  <verify>pnpm test packages/core/src/runner/runtime/__tests__/factory.test.ts passes</verify>
  <done>RuntimeFactory tests cover type selection, Docker wrapping, and combined scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI Output Parser and Session Path Tests</name>
  <files>
    packages/core/src/runner/runtime/__tests__/cli-output-parser.test.ts
    packages/core/src/runner/runtime/__tests__/cli-session-path.test.ts
  </files>
  <action>
Create unit tests for CLI output parsing and session path utilities.

**1. Create cli-output-parser.test.ts**:

Test the `parseCLILine` and `toSDKMessage` functions.

```typescript
import { describe, it, expect } from "vitest";
import { parseCLILine, toSDKMessage, type CLIMessage } from "../cli-output-parser.js";

describe("parseCLILine", () => {
  it("parses valid JSON line", () => {
    const line = '{"type":"assistant","message":"Hello"}';
    const result = parseCLILine(line);
    expect(result).toEqual({ type: "assistant", message: "Hello" });
  });

  it("returns null for empty line", () => {
    expect(parseCLILine("")).toBeNull();
  });

  it("returns null for whitespace-only line", () => {
    expect(parseCLILine("   ")).toBeNull();
  });

  it("returns null for invalid JSON", () => {
    expect(parseCLILine("not json")).toBeNull();
  });

  it("returns null for non-object JSON", () => {
    expect(parseCLILine('"just a string"')).toBeNull();
  });

  it("returns null for array JSON", () => {
    expect(parseCLILine('[1, 2, 3]')).toBeNull();
  });
});

describe("toSDKMessage", () => {
  it("transforms assistant message", () => {
    const cli: CLIMessage = { type: "assistant", message: "Hello" };
    const sdk = toSDKMessage(cli);
    expect(sdk.type).toBe("assistant");
    expect(sdk.message).toEqual({ type: "assistant", message: "Hello" });
  });

  it("transforms tool use message", () => {
    const cli: CLIMessage = {
      type: "tool_use",
      name: "Bash",
      input: { command: "ls" }
    };
    const sdk = toSDKMessage(cli);
    expect(sdk.type).toBe("tool_use");
  });

  it("transforms result message", () => {
    const cli: CLIMessage = {
      type: "result",
      result: "success",
      cost_usd: 0.05
    };
    const sdk = toSDKMessage(cli);
    expect(sdk.type).toBe("result");
  });

  it("handles unknown type gracefully", () => {
    const cli: CLIMessage = { type: "unknown_type" as any, data: "test" };
    const sdk = toSDKMessage(cli);
    expect(sdk.type).toBe("unknown_type");
  });

  it("preserves all original fields", () => {
    const cli: CLIMessage = {
      type: "assistant",
      message: "test",
      extra_field: "preserved"
    };
    const sdk = toSDKMessage(cli);
    expect(sdk.message.extra_field).toBe("preserved");
  });
});
```

**2. Create cli-session-path.test.ts**:

Test path encoding and session directory functions.

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { mkdir, rm, writeFile } from "node:fs/promises";
import {
  encodePathForCli,
  getCliSessionDir,
  getCliSessionFile,
} from "../cli-session-path.js";

describe("encodePathForCli", () => {
  it("encodes forward slashes to hyphens", () => {
    expect(encodePathForCli("/home/user/project")).toBe("-home-user-project");
  });

  it("handles paths with multiple consecutive slashes", () => {
    expect(encodePathForCli("/path//double")).toBe("-path--double");
  });

  it("handles root path", () => {
    expect(encodePathForCli("/")).toBe("-");
  });

  it("handles relative path", () => {
    expect(encodePathForCli("relative/path")).toBe("relative-path");
  });

  it("handles Windows-style paths", () => {
    // On all platforms, forward slashes are encoded
    expect(encodePathForCli("C:/Users/test")).toBe("C:-Users-test");
  });
});

describe("getCliSessionDir", () => {
  it("returns .claude/projects/encoded-path inside home dir", () => {
    const result = getCliSessionDir("/workspace/myproject");
    expect(result).toContain(".claude");
    expect(result).toContain("projects");
    expect(result).toContain("-workspace-myproject");
  });
});

describe("getCliSessionFile", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = join(tmpdir(), `cli-session-test-${Date.now()}`);
    await mkdir(tempDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it("finds session JSONL file in directory", async () => {
    // Create a mock session file
    const sessionDir = join(tempDir, ".claude", "projects", "test-workspace");
    await mkdir(sessionDir, { recursive: true });
    await writeFile(join(sessionDir, "session-abc123.jsonl"), "{}");

    // Note: getCliSessionFile looks in standard Claude directory
    // This test may need adjustment based on actual implementation
  });
});
```

Note: The session file tests may need adjustment based on actual implementation. Focus on the path encoding which is deterministic.
  </action>
  <verify>pnpm test packages/core/src/runner/runtime/__tests__/cli-output-parser.test.ts packages/core/src/runner/runtime/__tests__/cli-session-path.test.ts passes</verify>
  <done>CLI output parser and session path tests cover parsing, transformation, and path encoding</done>
</task>

<task type="auto">
  <name>Task 3: Create Docker Configuration Unit Tests</name>
  <files>packages/core/src/runner/runtime/__tests__/docker-config.test.ts</files>
  <action>
Create comprehensive unit tests for Docker configuration at `packages/core/src/runner/runtime/__tests__/docker-config.test.ts`.

Test all functions: parseMemoryToBytes, parseVolumeMount, getHostUser, resolveDockerConfig.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import {
  parseMemoryToBytes,
  parseVolumeMount,
  getHostUser,
  resolveDockerConfig,
  DEFAULT_DOCKER_IMAGE,
  DEFAULT_MEMORY_LIMIT,
  DEFAULT_MAX_CONTAINERS,
} from "../docker-config.js";

describe("parseMemoryToBytes", () => {
  describe("valid formats", () => {
    it("parses bytes (no suffix)", () => {
      expect(parseMemoryToBytes("1024")).toBe(1024);
    });

    it("parses kilobytes", () => {
      expect(parseMemoryToBytes("1k")).toBe(1024);
      expect(parseMemoryToBytes("1K")).toBe(1024);
      expect(parseMemoryToBytes("1kb")).toBe(1024);
    });

    it("parses megabytes", () => {
      expect(parseMemoryToBytes("1m")).toBe(1024 * 1024);
      expect(parseMemoryToBytes("512M")).toBe(512 * 1024 * 1024);
      expect(parseMemoryToBytes("1mb")).toBe(1024 * 1024);
    });

    it("parses gigabytes", () => {
      expect(parseMemoryToBytes("1g")).toBe(1024 * 1024 * 1024);
      expect(parseMemoryToBytes("2G")).toBe(2 * 1024 * 1024 * 1024);
      expect(parseMemoryToBytes("2gb")).toBe(2 * 1024 * 1024 * 1024);
    });

    it("parses terabytes", () => {
      expect(parseMemoryToBytes("1t")).toBe(1024 * 1024 * 1024 * 1024);
    });

    it("handles decimal values", () => {
      expect(parseMemoryToBytes("1.5g")).toBe(Math.floor(1.5 * 1024 * 1024 * 1024));
    });
  });

  describe("invalid formats", () => {
    it("throws for empty string", () => {
      expect(() => parseMemoryToBytes("")).toThrow("Invalid memory format");
    });

    it("throws for invalid suffix", () => {
      expect(() => parseMemoryToBytes("1x")).toThrow("Invalid memory format");
    });

    it("throws for negative values", () => {
      expect(() => parseMemoryToBytes("-1g")).toThrow("Invalid memory format");
    });

    it("throws for non-numeric", () => {
      expect(() => parseMemoryToBytes("abc")).toThrow("Invalid memory format");
    });
  });
});

describe("parseVolumeMount", () => {
  describe("valid formats", () => {
    it("parses host:container (default rw)", () => {
      const result = parseVolumeMount("/host/path:/container/path");
      expect(result).toEqual({
        hostPath: "/host/path",
        containerPath: "/container/path",
        mode: "rw",
      });
    });

    it("parses host:container:ro", () => {
      const result = parseVolumeMount("/host/path:/container/path:ro");
      expect(result).toEqual({
        hostPath: "/host/path",
        containerPath: "/container/path",
        mode: "ro",
      });
    });

    it("parses host:container:rw explicitly", () => {
      const result = parseVolumeMount("/host/path:/container/path:rw");
      expect(result).toEqual({
        hostPath: "/host/path",
        containerPath: "/container/path",
        mode: "rw",
      });
    });
  });

  describe("invalid formats", () => {
    it("throws for single path", () => {
      expect(() => parseVolumeMount("/only/one")).toThrow("Invalid volume format");
    });

    it("throws for too many colons", () => {
      expect(() => parseVolumeMount("/a:/b:ro:extra")).toThrow("Invalid volume format");
    });

    it("throws for invalid mode", () => {
      expect(() => parseVolumeMount("/a:/b:invalid")).toThrow("Invalid volume mode");
    });
  });
});

describe("getHostUser", () => {
  it("returns UID:GID format", () => {
    const user = getHostUser();
    expect(user).toMatch(/^\d+:\d+$/);
  });

  it("uses process.getuid and process.getgid when available", () => {
    // On POSIX systems, these should return actual values
    if (process.getuid && process.getgid) {
      const user = getHostUser();
      expect(user).toBe(`${process.getuid()}:${process.getgid()}`);
    }
  });
});

describe("resolveDockerConfig", () => {
  it("applies defaults when called with undefined", () => {
    const config = resolveDockerConfig(undefined);
    expect(config.enabled).toBe(false);
    expect(config.ephemeral).toBe(false);
    expect(config.image).toBe(DEFAULT_DOCKER_IMAGE);
    expect(config.network).toBe("bridge");
    expect(config.memoryBytes).toBe(parseMemoryToBytes(DEFAULT_MEMORY_LIMIT));
    expect(config.maxContainers).toBe(DEFAULT_MAX_CONTAINERS);
    expect(config.workspaceMode).toBe("rw");
    expect(config.volumes).toEqual([]);
  });

  it("applies defaults when called with empty object", () => {
    const config = resolveDockerConfig({});
    expect(config.enabled).toBe(false);
    expect(config.image).toBe(DEFAULT_DOCKER_IMAGE);
  });

  it("respects provided values", () => {
    const config = resolveDockerConfig({
      enabled: true,
      image: "custom:latest",
      network: "none",
      memory: "4g",
      cpu_shares: 512,
      user: "1001:1001",
      workspace_mode: "ro",
      ephemeral: true,
      max_containers: 10,
      volumes: ["/data:/data:ro"],
    });

    expect(config.enabled).toBe(true);
    expect(config.image).toBe("custom:latest");
    expect(config.network).toBe("none");
    expect(config.memoryBytes).toBe(4 * 1024 * 1024 * 1024);
    expect(config.cpuShares).toBe(512);
    expect(config.user).toBe("1001:1001");
    expect(config.workspaceMode).toBe("ro");
    expect(config.ephemeral).toBe(true);
    expect(config.maxContainers).toBe(10);
    expect(config.volumes).toHaveLength(1);
    expect(config.volumes[0].hostPath).toBe("/data");
  });

  it("handles base_image as alias for image", () => {
    const config = resolveDockerConfig({
      enabled: true,
      base_image: "legacy:tag",
    });
    expect(config.image).toBe("legacy:tag");
  });

  it("prefers image over base_image", () => {
    const config = resolveDockerConfig({
      enabled: true,
      image: "preferred:tag",
      base_image: "legacy:tag",
    });
    expect(config.image).toBe("preferred:tag");
  });
});

describe("constants", () => {
  it("DEFAULT_DOCKER_IMAGE is set", () => {
    expect(DEFAULT_DOCKER_IMAGE).toBe("anthropic/claude-code:latest");
  });

  it("DEFAULT_MEMORY_LIMIT is 2g", () => {
    expect(DEFAULT_MEMORY_LIMIT).toBe("2g");
  });

  it("DEFAULT_MAX_CONTAINERS is 5", () => {
    expect(DEFAULT_MAX_CONTAINERS).toBe(5);
  });
});
```
  </action>
  <verify>pnpm test packages/core/src/runner/runtime/__tests__/docker-config.test.ts passes</verify>
  <done>Docker config tests cover memory parsing, volume parsing, user detection, and config resolution</done>
</task>

</tasks>

<verification>
1. All test files exist in packages/core/src/runner/runtime/__tests__/:
   - factory.test.ts
   - cli-output-parser.test.ts
   - cli-session-path.test.ts
   - docker-config.test.ts

2. All tests pass:
   ```bash
   pnpm test packages/core/src/runner/runtime/__tests__/
   ```

3. Test coverage:
   - RuntimeFactory: type selection, Docker wrapping
   - CLI parser: JSON parsing, message transformation
   - Session paths: encoding, directory resolution
   - Docker config: memory parsing, volume parsing, defaults
</verification>

<success_criteria>
- Unit tests exist for RuntimeFactory, CLI parser, session paths, and Docker config
- All tests pass with `pnpm test`
- Tests cover both success and error cases
- Tests follow existing codebase patterns (Vitest, describe/it/expect)
</success_criteria>

<output>
After completion, create `.planning/phases/04-documentation-and-testing/04-03-SUMMARY.md`
</output>
